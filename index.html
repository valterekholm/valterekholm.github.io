<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<title>F(x) square_shooter v.2</title>
<style>
body{
font-size:16px;
margin: 0;
}
button, input, input[type="button"], input[type="number"]{
font-size:40px;
width: 23%;
}
input[type="range"]{
width:90%;
}
#decrease:before{
    content: "<--";
}
#increase:before{
    content: "-->";
}
#board{
position: relative;
width: 700px;
height: 700px;
border: 1px solid gray;
background: rgba(200,200,100,.3);
background-image: url("circle.png");
background-repeat: no-repeat;
background-position: 328px 680px;
margin: 10px auto;
overflow: hidden;
}
#gun{
position: absolute;
left: 350px;
bottom: 0;
width: 100px;
height: 100px;
background-image: url("line45.png");
background-size: cover;
}
#gun_{
position: absolute;
left: 350px;
bottom: 0;
width: 100px;
height: 100px;
}
#beam{
position: absolute;
left: 100px;
bottom: 0;
width: 50px;
height: 50px;
}
#window{
position: absolute;
width: 150px;
height: 1px;
border: 1px solid black;
right: 100px;
background-color: black;
opacity: 1;
visibility: hidden;
transition: border 1s, opacity 2s, background-color 1s;
}

#info{
position:absolute;
top:0;
right:0;
width:20px;
height:20px;
background-color:green;
border: 2px solid #4a5;
text-align: center;
cursor: pointer;
transition: all 3s;
font-size: 1em;
}
#info.bigger{
width:30px;
height:30px;
font-size: 1.1em;
}

.holder{
background: white;
text-align: center;
}

#window.blow{
    border: 4px dotted red;
    background-color: gray;
    border-radius: 3px;
    padding: 3px;
    opacity: 0;
}
#window.vanish{
    border: 4px dotted red;
    background-color: gray;
    border-radius: 3px;
    padding: 3px;
    opacity: 0;
}
#banner{
position: fixed;
width:50%;
left: -25%;
margin: 0 auto;
padding:40px 20px;
text-align: center;
background-color: rgba(255,255,255,.5);
opacity:0;
transition: all 1s;
z-index: 100;
}
#banner.showing{
opacity:1;
left: 10%;
width: 80%;
}

#hearts{
padding: 15px;
}

#points{
text-align: center;
}

</style>
</head>
<body>
<div class="holder">

<div id="banner"></div>
<div id="board">
<div id="info" class="bigger">?</div>


<!--div id="gun">
</div-->

<div id="window"></div>

<!--img src="line45.png" id="gun_"-->
<svg height="100" width="100" style="position:absolute; bottom:0; left: 300px" id="svgGun">
    <line x1="50" y1="100" x2="50" y2="0" style="stroke:rgb(0,0,0);stroke-width:2" id="line1" />
</svg>

<!--img src="line45.png" id="beam"-->
<svg height="50" width="50" style="position:absolute; bottom:0; left: 300px" id="svgBeam">
    <line x1="0" y1="50" x2="50" y2="50" style="stroke:rgb(0,0,0);stroke-width:2" id="line2" />
</svg>
</div>

</div><!-- holder -->

<div class="holder">

<!--button id="decrease"></button>
<button id="increase"></button-->
<input type="range" id="aimer" min="-90" max="90">
<input id="status" type="number" readonly>
<input type="button" id="fire" value="Fire">
</div>

<div class="holder" id="hearts">
</div>

<div class="holder" id="points"></div>

<script>
/*Gun movement must be max one degree at a time, se note A*/
GUN_SIZE = 100;
BEAM_SIZE = 25;
GUN_X_OFFSET = 350;
SVG_GUN_WIDTH = 100;//ALSO HEIGHT
WAIT_AFTER_HIT = 3000;
minHitDecay = 1000;
MAX_TARGET_STEP = 5;//higher is faster
angle = 1; oldAngle = 0;

MAX_GUN_ANGLE = 85;

interv1 = null;
intervBeam = null;
intervTarget = null;

interv1_copy = null;
intervBeam_copy = null;
intervTarget_copy = null;

intervBeam_ = 80;
targetStep = 1;
intervWindow_ = 20;
statusField = null;
gunImg = null;
fireBtn = null;
beamImg = null;
window_ = null;//target
info = null;
banner = null;//banner for info
fx = 2;

hearts = null; //eleme
heartsCount = 10;

points = null; //eleme
pointsCount = 0;

svgGun = null;
svgBeam = null;
svgBeamOuter = null;
is_fired = false;

outerX = 700;
outerY = 700;//todo: make as board size

sizes = []; //img_sizes
sincoses = [];
sincoses1 = [];//real

beamObj = {};

window.onload = function(){

window.addEventListener("keydown", function(ev){
//todo make like keypress but for arrow btns
    //console.log(ev);
    switch(ev.keyCode){
        case 32:
            //console.log("SPACE");
            fireHit();
        break;
        case 38://up
        case 37://left
            moveGun(-1);
        break;
        case 39:
        case 40:
            moveGun(1);
        break;
        case 65: //a
            makeBreak();
        break;
        case 73: //i
            increaseTargetSpeed();
        break;
    }
});


info = document.querySelector("#info");

info.addEventListener("click", function(){
    messageBanner("<h1>Use arrows to aim, fire with space-bar.</h1>");
});

info.className = "";//for animation (transition)

points = document.querySelector("#points");

banner = document.querySelector("#banner");

svgGun = document.querySelector("#line1");
svgBeam = document.querySelector("#line2");
svgBeamOuter = document.querySelector("#svgBeam");

//test
//var testy = 3;
//var testx = getXFromY(testy);
//console.log("testx from y "+testy+" :" + testx);

for(var i=-90; i<90; i++){
    sincoses.push(getXYSvg(i, GUN_SIZE, GUN_SIZE/2, GUN_SIZE));//getWidthHeight(i, GUN_SIZE));
    sincoses1.push({x:Math.sin(i / 360 * Math.PI * 2), y:Math.cos(i / 360 * Math.PI * 2)});
//console.log("i " + i + ": " + Math.sin(i / 360 * Math.PI * 2));
}

statusField = document.querySelector("#status");
gunImg = document.querySelector("#gun_");
//beamImg = document.querySelector("#beam");
window_ = document.querySelector("#window");
//setImgSizes(gunImg, sizes[20]);


var decr = document.querySelector("#decrease");
var incr = document.querySelector("#increase");
var aimer = document.querySelector("#aimer");
fireBtn = document.querySelector("#fire");
/*
decr.addEventListener("mousedown", function(){console.log("decrease down"); triggerGunMove(-1)});
decr.addEventListener("mouseup", function(){console.log("decrease up"); abortGunMove()});

incr.addEventListener("mousedown", function(){console.log("increase down"); triggerGunMove(+1)});
incr.addEventListener("mouseup", function(){console.log("increase up"); abortGunMove()});
*/
aimer.addEventListener("input", function(){
console.log("aimer at " + this.value);
angle=parseInt(this.value);
setGunPointPos(sincoses[angle+90].x, sincoses[angle+90].y);
});

fireBtn.addEventListener("click", function(){
    fireHit();
});




//auto update the angle status field
setInterval(function(){statusField.value = angle;}, 100);

setGunPointPos(sincoses[angle+90].x, sincoses[angle+90].y);

initTarget();
initSvgBeam(angle);

hearts = document.querySelector("#hearts");
for(var i=0; i<heartsCount; i++){
    drawOneHeart();
    }

}

function fireHit(){
    if(is_fired){ return }

    initSvgBeam(angle);
    shoot(angle);
    is_fired = true;

    disableButton(fireBtn);
}

/*pass 1 or -1*/
/*for buttons pushed, start moving gun by interval*/
function triggerGunMove(step){
    interv1 = setInterval(
    function(){
        oldAngle = angle; //Note A: save old to compare in order to know when to switch image file
        angle += parseInt(step);

        if(angle >= MAX_GUN_ANGLE) angle = MAX_GUN_ANGLE-1;
        if(angle <= - MAX_GUN_ANGLE) angle = -(MAX_GUN_ANGLE)+1;

        setGunPointPos(sincoses[angle+90].x, sincoses[angle+90].y);

    }, 100);
}
/*When button is released*/
function abortGunMove(){
    clearInterval(interv1);
}

function moveGun(step){
        oldAngle = angle; //Note A: save old to compare in order to know when to switch image file
        angle += parseInt(step);
        if(angle >= MAX_GUN_ANGLE) angle = MAX_GUN_ANGLE-1;
        if(angle <= - MAX_GUN_ANGLE) angle = -(MAX_GUN_ANGLE)+1;

        setGunPointPos(sincoses[angle+90].x, sincoses[angle+90].y);
        //var _x2, _y2;

        //_x2 = sincoses1[angle+90].x * BEAM_SIZE;
        //_y2 = sincoses1[angle+90].y * -BEAM_SIZE + 100;

        //var wh = sizes[angle]; //getWidthHeight(angle, GUN_SIZE);

}

function getWidthHeight(ang, factor){
    var sinus = Math.sin(ang / 360 * Math.PI * 2);
    var cosinus = Math.cos(ang / 360 * Math.PI * 2);
    var ret = {};
    ret.width = sinus * factor;
    ret.height = cosinus * factor;
    return ret;
}

function getXYSvg(ang, size, xoffset, yoffset){
    var x = calcSvgGunXPos(ang, size, xoffset);
    var y = calcSvgGunYPos(ang, size, yoffset)
    var ret = {};
    ret.x = x;
    ret.y = y;
    return ret;
}

function setImgSizes(imgElem, sizes){
    imgElem.style.width = sizes.width+"px";
    imgElem.style.height = sizes.height+"px";
}

function checkIfThinSwitch(angle_, oldAngle_){
    if(angle_ == SWITCH_IMG_LOW2 && oldAngle_ == SWITCH_IMG_LOW2+1) return -2;
    else if(angle_ == SWITCH_IMG_LOW && oldAngle_ == SWITCH_IMG_LOW+1 || angle_ == SWITCH_IMG_LOW2+1 && oldAngle_ == SWITCH_IMG_LOW2) return -1;
    else if(angle_ == SWITCH_IMG_HIGH && oldAngle_ == SWITCH_IMG_HIGH-1 || angle_ == SWITCH_IMG_HIGH2-1 && oldAngle_ == SWITCH_IMG_HIGH2) return 1;
    else if(angle_ == SWITCH_IMG_HIGH2 && oldAngle_ == SWITCH_IMG_HIGH2-1) return 2;
    else if(angle_ == SWITCH_IMG_LOW+1 && oldAngle_ == SWITCH_IMG_LOW || angle_ == SWITCH_IMG_HIGH-1 && oldAngle_ == SWITCH_IMG_HIGH) return 0;
    return null;
}

function setImgSrc(imgElem, fileName){
    imgElem.src = fileName;
}

function initBeam(beamImg_, angle_){
    var wh = getWidthHeight(angle_, GUN_SIZE);
    beamImg_.style.left = wh.width + "px";
    beamImg_.style.bottom = wh.height + "px";//setting pos
    beamImg_.style.visibility = "hidden";
    is_fired = false;

    drawPoints();//test
    enableButton(fireBtn);
}

function initSvgBeam(angle_){
    var xy = getXYSvg(angle_, BEAM_SIZE*2, 0, BEAM_SIZE);
    var beamPos = getXYSvg(angle_, GUN_SIZE, 0, GUN_SIZE);

/*GUN_X_OFFSET = 350;
SVG_GUN_WIDTH = 100;*/

    svgBeamOuter.style.width = BEAM_SIZE + "px";
    svgBeamOuter.style.height = BEAM_SIZE + "px";
    svgBeamOuter.style.border = "0 solid gray";
    svgBeamOuter.style.visibility = "hidden";
    //svgBeamOuter.style.background = "#ccc";
    if(angle_ >= 0){
        svgBeamOuter.style.left = GUN_X_OFFSET + beamPos.x + "px";
        setBeamPointPos(xy.x, xy.y, true);
    }
    else{
        svgBeamOuter.style.left = GUN_X_OFFSET - BEAM_SIZE + beamPos.x + "px";
        setBeamPointPos(xy.x, xy.y, false);
    }
    svgBeamOuter.style.bottom = SVG_GUN_WIDTH - beamPos.y + "px";


    is_fired = false;

    drawPoints();//test
    enableButton(fireBtn);
}

function drawPoints(){
    var h3 = document.createElement("h3");
    h3.innerHTML = pointsCount;
    points.innerHTML = "";
    points.appendChild(h3);
}

function shoot(angle_){
    console.log("shoot angle " + angle_);
/*
    var wh2 = getWidthHeight(angle_, BEAM_SIZE);
    var width = wh2.width;
    beamImg_.style.width = width + "px";
    var height = wh2.height;
    beamImg_.style.height = height + "px";
    beamImg_.style.visibility = "visible";//todo:hide when needed
*/
    //initSvgBeam(angle_);
    svgBeamOuter.style.visibility = "visible";

    var x = sincoses1[angle_+90].x;
    var y = sincoses1[angle_+90].y;
    //console.log("got x: " + x);
    x *= BEAM_SIZE;
    y *= BEAM_SIZE;

    var tan = Math.tan(angle_ * Math.PI/180);
    fx = 1 / tan; //what could be used in a formula f(x), y as function of x
    //console.log("fx is set to " + fx);
    //console.log("Tan is " + tan + " fx? " + fx);
    intervBeam = setInterval(function(){
        moveSvgBeam(x, y);        
    }, intervBeam_);//extract
    is_fired = true;//todo: depend on pos of beam
}

function moveBeam(beamImg_, stepX, stepY){
    stepX *= .9;
    stepY *= .9;//test to make path covered

    var px = parseInt(beamImg.style.left);//removing the "px" or similar from css
    var py = parseInt(beamImg.style.bottom);
    px += parseInt(stepX);
    py += parseInt(stepY);//pos x y
    beamImg_.style.left = px + "px";
    beamImg_.style.bottom = py + "px";
    //console.log(px);
    if(px > outerX || py > outerY){
        cancelBeam();
        initBeam(beamImg, angle);
        is_fired = false;
    }
}

function moveSvgBeam(x, y){
    //console.log("moveSvgBeam med x y: " + x + " " + y + " isFired: " + is_fired);
    x *= .9;
    y *= .9;//test to make path covered

    var px = parseInt(svgBeamOuter.style.left);//removing the "px" or similar from css
    var py = parseInt(svgBeamOuter.style.bottom);
    px += parseInt(x);
    py += parseInt(y);//pos x y
    //console.log("new x: " + px);
    svgBeamOuter.style.left = px + "px";
    svgBeamOuter.style.bottom = py + "px";
    //console.log(px);

    var baseX = 0;
    if(x<0){
        baseX = px + BEAM_SIZE;
    }
    else{
        baseX = px;
    }
    //console.log("baseX " + baseX);    

    if(baseX > outerX || baseX < 0 || py > outerY){
        cancelBeam();
        //initBeam(beamImg, angle);
        initSvgBeam(angle);
        is_fired = false;
    }
}

function cancelBeam(){
    clearInterval(intervBeam);
}

function initTarget(){
    var targetHighest = 600;
    var targetLowest = 170;//hight from "ground"

    var minLen = 100, maxLen=200;

    window_.style.left = outerX + "px";
    var rand = Math.random();
    var diff = targetHighest - targetLowest;
    var y = rand*diff+targetLowest;
    window_.style.bottom = parseInt(y)+"px";
    //console.log("window_ bottom set to " + y + ", " + window_.style.bottom);
    var rand2 = Math.random();
    var diff2 = maxLen - minLen;
    var len = parseInt(rand2*diff2+minLen);//target width
    window_.style.width = len + "px";
    window_.style.visibility = "visible";
    window_.className = "";

    intervTarget = setInterval(function(){
        var posx = parseInt(window_.style.left);
        posx-=parseInt(targetStep);
        window_.style.left = posx + "px";
        var width = parseInt(window_.style.width);
        var posy = parseInt(window_.style.bottom);

        //collision check
        //1. is beam in same x
        var beamL = getElemLeft(svgBeamOuter);
        var beamR = getElemRight(svgBeamOuter);
        var beamBottom = getElemBottom(svgBeamOuter);
        var beamTop = getElemTop(svgBeamOuter);
        if(posx < parseInt(len)*-1){//has passed over screen
            console.log("<0");
            clearInterval(intervTarget);
            initTarget();
            heartsCount--;
            removeLastChild(hearts);
            if(heartsCount==0){
                makeBreak();
                messageBanner("<h1>Game Over</h1>");
            }
            //setTimeout(function(){}, 300);            
        }
        if(AOverlapsB(beamL, beamR, posx, posx+width) && is_fired){
            //2. get x for y (window)
            var x = getXFromY(posy, GUN_X_OFFSET); //x for y the height of the window
            //is x inbetween window x1, x2
            if(x >= posx && x <= posx+width){
                //console.log("Crossing path x:" + x + ", posx1:" + posx + "posx2: " + (posx+width));
                if(beamBottom < posy && beamTop > posy){
                    console.log("Hit x:" + x + ", posx1:" + posx + ", posx2: " + (posx+width));
                    pointsCount += parseInt(posy*targetStep)+len+angle; //height of target, speed of it, angle of gun
                    cancelBeam();
                    initSvgBeam(angle);
                    window_.className += " blow";
                    clearInterval(intervTarget);//moved from timeOuted function below because of error if shooting again after hit
                    if(targetStep <= MAX_TARGET_STEP){ increaseTargetSpeed() }
                    
                    setTimeout(
                        function(){
                            //clearInterval(intervTarget); //moved up
                            initTarget();
                            is_fired = false;
                        }, WAIT_AFTER_HIT);
                    if(WAIT_AFTER_HIT > minHitDecay){ WAIT_AFTER_HIT-=100; }
                    fx = 0;
                }
            }
            else{
                //console.log("Miss x:" + x + ", posx1:" + posx + "posx2: " + (posx+width));
            }
        } 
    }, intervWindow_);   
}

function increaseTargetSpeed(){
    targetStep += 0.5; //it should then be rounded to integer
}

function getElemBottom(elem){
    var py = parseInt(elem.style.bottom);
    return py;
}

function getElemTop(elem){
    var py = parseInt(elem.style.bottom);
    var height = parseInt(elem.style.height);
    return py + height;
}

function getFx(x){
    return x * fx;
}

function getXFromY(y, xOffset){
    if(typeof xOffset == "undefined") xOffset = 0;
    //console.log("getXFromY " + y + " and fx is " + fx);
    return y / fx + xOffset;
}

function getElemLeft(elem){
    var px = parseInt(elem.style.left);
    return px;
}

function getSvgBeamLeft(){
    var px = parseInt(svgBeamOuter.style.left);
    return px;
}

function getElemRight(elem){
    var px = parseInt(elem.style.left);
    var width = parseInt(elem.style.width);
    return px+width;
}

function getSvgBeamRight(){
    var px = parseInt(svgBeamOuter.style.left);
    var width = parseInt(svgBeamOuter.style.width);
    return px+width;
}

function AOverlapsB(aMin, aMax, bMin, bMax){
    if(aMin > aMax || bMin > bMax) return false;

    var overlap = aMin < bMax && bMin < aMax;

    return overlap;// from https://stackoverflow.com/questions/13513932/algorithm-to-detect-overlapping-periods
}

function messageBanner(html){
    banner.className="showing";
    setTimeout(function(){banner.innerHTML = html}, 500);
    setTimeout(function(){banner.className = ""}, 3500);
}

//brakes game
function makeBreak(){
    clearInterval(interv1);
    clearInterval(intervBeam);
    clearInterval(intervTarget);//todo: make startable
}

function drawOneHeart(){
    var newHeart = document.createElement("img");
    newHeart.src = "heart.png";
    hearts.appendChild(newHeart);
}

function removeLastChild(container){
    var lc = container.lastElementChild;
    container.removeChild(lc);
}

function disableButton(elem){
    elem.disabled = true;
}
function enableButton(elem){
    elem.disabled = false;
}

/*for x2, y2    */
function setGunPointPos(x, y){
    //console.log("sGPP " + x + "," + y);
    //console.log(svgGun);
    svgGun.x2.baseVal.value = x;
    svgGun.y2.baseVal.value = y;
}

function setBeamPointPos(x, y, positiveAngle){
    if(positiveAngle){
        svgBeam.x2.baseVal.value = x;
        //base
        svgBeam.x1.baseVal.value = 0;
    }
    else{
        svgBeam.x2.baseVal.value = x+BEAM_SIZE;
        //base
        svgBeam.x1.baseVal.value = BEAM_SIZE;
    }
    svgBeam.y2.baseVal.value = y;
    svgBeam.y1.baseVal.value = BEAM_SIZE;
}

function calcSvgGunXPos(angle_, size, offset){
    return Math.sin(angle_ / 360 * Math.PI * 2) * (size / 2) + offset;
}
function calcSvgGunYPos(angle_, size, offset){
    return Math.cos(angle_ / 360 * Math.PI * 2) * (-size / 2) + offset;
}
</script>

</body>
</html>
